#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("spline.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    loc<-0.05#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.3), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    loc<-0.05#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.3), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    loc<-0.05#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.3), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    loc<-0.05#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{#
	A<-ComputeESE_spline(0.2/20,X,y,dummy,m)	#
  	min <- 1.0e8#
  	loc<-0.1/20#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.2*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.2*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{#
	A<-ComputeESE_spline(0.2/20,X,y,dummy,m)	#
  	min <- 1.0e8#
  	loc<-0.1/20#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.2*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.2*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{#
	A<-ComputeESE_spline(0.2/20,X,y,dummy,m)	#
  	min <- 1.0e8#
  	loc<-0.01/20#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.2*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.01/20+0.01*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{#
	A<-ComputeESE_spline(0.2/20,X,y,dummy,m)	#
  	min <- 1.0e8#
  	loc<-0.02/20#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y, edr_hat,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y, edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1000#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1000#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,a0,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 5#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE_spline(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese_spline<-ComputeESE(loc,X,y,edr_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese_spline<-ComputeESE(X,y,ese_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 5#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    ese_spline<-ComputeESE(X,y,ese_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 5#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
#ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
#ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,edr_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese_spline<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese_spline$psi#
	B <- ese_spline$derivative#
	C <- ese_spline$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y,edr_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with EDR as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.16), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1000#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1000#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1000#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 1000#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,sse_hat,m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,sse_hat,m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	print(sse_hat)#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,sse_hat,m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
	####   MONOTONE REGRESSION        #######
	#########################################################
	rm(list=ls())#
	library(Rcpp)#
	library(pracma) #
	library(simest)#
	args(sim.est)#
	library(EDR)#
	library(MASS)#
	source("LagrangePLSE.R")#
	source("NewSimEst.R")#
	sourceCpp("SSE.cpp")#
	sourceCpp("ESE.cpp")#
	sourceCpp("SSE_spline.cpp")#
	sourceCpp("ESE_spline.cpp")#
	crossval <- function(X,y,dummy,m)#
	{	#
	  	min <- 1.0e8#
	    for (i in 1:20)#
	    {#
	      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
	      	a<-A$crossval#
	      	if (!is.na(a))#
	      	{#
	      	    if (a<min)#
	      	    {#
	        	    min <-a#
	        	    loc<-0.02*i/20#
	      	    }#
	      	}#
	    }#
	    return(loc)#
	}#
	  NumIt = 100#
	  n = 500#
	  m= 15#
	  sigma = 1#
	  mu=0.05#
	  #out=matrix(0,NumIt,m)#
	  timeMat <- NULL#
	   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
	  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
	for (j in 1: NumIt){#
	  sim = 101+j#
	  set.seed(sim)#
	  print(j)#
	  a0 = c(rep(1,m))/sqrt(m)#
		#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
		X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
		z=X%*%a0#
		y=(z)^3 + rnorm(n,0,sigma)#
		# EDR estimate proposed by Hristache et al.#
		starter_edr = proc.time()#
		EDR <- edr(X,y,method = "HJPS")#
		edr_hat = -summary(EDR)$Rhat[1,]#
		time_edr = (proc.time() -starter_edr)[3]#
		# SSE#
		starter_sse = proc.time()#
		SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
		sse_hat = SSE$alpha#
		print(sse_hat)#
		time_sse = (proc.time() -starter_sse)[3]#
		# ESE#
		starter_ese = proc.time()#
		ESE <- ComputeESE(X,y,sse_hat,m)#
		ese_hat = ESE$alpha#
		time_ese = (proc.time() -starter_ese)[3]#
		## SSE_spline estimator#
		starter_sse_spline = proc.time()#
		sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
		sse_spline_hat = sse_spline$alpha#
		time_sse_spline = (proc.time() -starter_sse_spline)[3]#
	  ## ESE_spline computed via Lagrange + Broyden#
	  starter_ese_lagrange = proc.time()#
	  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
	  ese_lagrange_hat = ese_lagrange$theta#
	  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
	    ## spline estimator#
	    	starter_ese_spline = proc.time()#
	    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
	 	print(loc)#
	  	starter_ese_spline = proc.time()#
		ese_spline <- ComputeESE_spline(loc,X,y,sse_hat,m)#
	  	ese_spline_hat = ese_spline$alpha#
	  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
	  #Simest with sse_hat as starting point#
	  starter_simest= proc.time()#
	  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
	  time_simest = (proc.time() -starter_simest)[3]#
	  #Simest with a0 as starting point#
	  starter_simest0= proc.time()#
	  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
	  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
	  time_simest0 = (proc.time() -starter_simest0)[3]#
	  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
	timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
	  # Write edr-estimates (last column contains the computation time )#
	   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
	  #  # Write sse-estimates (last column contains the computation time )#
	  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
	  #    # Write ese-estimates (last column contains the computation time )#
	  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
	  #   # Write pls-estimates (last column contains the computation time )#
	  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
	  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
	   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
	  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
	   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
	   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
	   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
	}#
	  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
	pdf("BoxPlotThetaErrAndTime.pdf")#
	boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
	boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
	boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
	dev.off()#
	ese<-ComputeESE(X,y,sse_hat,m)#
		A <- ese$psi#
		B <- ese$derivative#
		C <- ese$data#
	    x1<-A[,1]#
	    y1<-A[,2]#
	    x2<-B[,1]#
	    y2<-B[,2]#
	    x<-C[,1]#
	   	y<-C[,2]#
	    f <- function(x) {x^3}#
	    x0<-seq(min(x1),max(x1),by=0.01)#
	    y0<-f(x0)#
	    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
	    lines(x1,y1,col="blue",lwd=2,type="s")#
	    lines(x0,y0,lwd=2,col="red",lty=2)#
	    points(x,y,pch = 21)#
	    g <- function(x) {3*x^2}#
	    x0<-seq(min(x2),max(x2),by=0.1)#
	    y0<-g(x0)#
	    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
	    lines(x2,y2,lwd=2)#
	    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
	####   MONOTONE REGRESSION        #######
	#########################################################
	rm(list=ls())#
	library(Rcpp)#
	library(pracma) #
	library(simest)#
	args(sim.est)#
	library(EDR)#
	library(MASS)#
	source("LagrangePLSE.R")#
	source("NewSimEst.R")#
	sourceCpp("SSE.cpp")#
	sourceCpp("ESE.cpp")#
	sourceCpp("SSE_spline.cpp")#
	sourceCpp("ESE_spline.cpp")#
	crossval <- function(X,y,dummy,m)#
	{	#
	  	min <- 1.0e8#
	    for (i in 1:20)#
	    {#
	      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
	      	a<-A$crossval#
	      	if (!is.na(a))#
	      	{#
	      	    if (a<min)#
	      	    {#
	        	    min <-a#
	        	    loc<-0.02*i/20#
	      	    }#
	      	}#
	    }#
	    return(loc)#
	}#
	  NumIt = 100#
	  n = 500#
	  m= 15#
	  sigma = 1#
	  mu=0.05#
	  #out=matrix(0,NumIt,m)#
	  timeMat <- NULL#
	   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
	  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
	for (j in 1: NumIt){#
	  sim = 101+j#
	  set.seed(sim)#
	  print(j)#
	  a0 = c(rep(1,m))/sqrt(m)#
		#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
		X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
		z=X%*%a0#
		y=(z)^3 + rnorm(n,0,sigma)#
		# EDR estimate proposed by Hristache et al.#
		starter_edr = proc.time()#
		EDR <- edr(X,y,method = "HJPS")#
		edr_hat = -summary(EDR)$Rhat[1,]#
		time_edr = (proc.time() -starter_edr)[3]#
		# SSE#
		starter_sse = proc.time()#
		SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
		sse_hat = SSE$alpha#
		print(sse_hat)#
		time_sse = (proc.time() -starter_sse)[3]#
		# ESE#
		starter_ese = proc.time()#
		ESE <- ComputeESE(X,y,sse_hat,m)#
		ese_hat = ESE$alpha#
		time_ese = (proc.time() -starter_ese)[3]#
		## SSE_spline estimator#
		starter_sse_spline = proc.time()#
		sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
		sse_spline_hat = sse_spline$alpha#
		time_sse_spline = (proc.time() -starter_sse_spline)[3]#
	  ## ESE_spline computed via Lagrange + Broyden#
	  starter_ese_lagrange = proc.time()#
	  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
	  ese_lagrange_hat = ese_lagrange$theta#
	  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
	    ## spline estimator#
	    	starter_ese_spline = proc.time()#
	    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
	 	print(loc)#
	  	starter_ese_spline = proc.time()#
		ese_spline <- ComputeESE_spline(loc,X,y,sse_hat,m)#
	  	ese_spline_hat = ese_spline$alpha#
	  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
	  #Simest with sse_hat as starting point#
	  starter_simest= proc.time()#
	  simest_hat <- Alter_Min_Simest(X, y, beta_init = edr_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
	  time_simest = (proc.time() -starter_simest)[3]#
	  #Simest with a0 as starting point#
	  starter_simest0= proc.time()#
	  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
	  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
	  time_simest0 = (proc.time() -starter_simest0)[3]#
	  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
	timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
	  # Write edr-estimates (last column contains the computation time )#
	   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
	  #  # Write sse-estimates (last column contains the computation time )#
	  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
	  #    # Write ese-estimates (last column contains the computation time )#
	  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
	  #   # Write pls-estimates (last column contains the computation time )#
	  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
	  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
	   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
	  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
	   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
	   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
	   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
	}#
	  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
	pdf("BoxPlotThetaErrAndTime.pdf")#
	boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
	boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
	boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
	dev.off()#
	ese<-ComputeESE(X,y,sse_hat,m)#
		A <- ese$psi#
		B <- ese$derivative#
		C <- ese$data#
	    x1<-A[,1]#
	    y1<-A[,2]#
	    x2<-B[,1]#
	    y2<-B[,2]#
	    x<-C[,1]#
	   	y<-C[,2]#
	    f <- function(x) {x^3}#
	    x0<-seq(min(x1),max(x1),by=0.01)#
	    y0<-f(x0)#
	    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
	    lines(x1,y1,col="blue",lwd=2,type="s")#
	    lines(x0,y0,lwd=2,col="red",lty=2)#
	    points(x,y,pch = 21)#
	    g <- function(x) {3*x^2}#
	    x0<-seq(min(x2),max(x2),by=0.1)#
	    y0<-g(x0)#
	    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
	    lines(x2,y2,lwd=2)#
	    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
	####   MONOTONE REGRESSION        #######
	#########################################################
	rm(list=ls())#
	library(Rcpp)#
	library(pracma) #
	library(simest)#
	args(sim.est)#
	library(EDR)#
	library(MASS)#
	source("LagrangePLSE.R")#
	source("NewSimEst.R")#
	sourceCpp("SSE.cpp")#
	sourceCpp("ESE.cpp")#
	sourceCpp("SSE_spline.cpp")#
	sourceCpp("ESE_spline.cpp")#
	crossval <- function(X,y,dummy,m)#
	{	#
	  	min <- 1.0e8#
	    for (i in 1:20)#
	    {#
	      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
	      	a<-A$crossval#
	      	if (!is.na(a))#
	      	{#
	      	    if (a<min)#
	      	    {#
	        	    min <-a#
	        	    loc<-0.02*i/20#
	      	    }#
	      	}#
	    }#
	    return(loc)#
	}#
	  NumIt = 100#
	  n = 500#
	  m= 15#
	  sigma = 1#
	  mu=0.05#
	  #out=matrix(0,NumIt,m)#
	  timeMat <- NULL#
	   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
	  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
	for (j in 1: NumIt){#
	  sim = 101+j#
	  set.seed(sim)#
	  print(j)#
	  a0 = c(rep(1,m))/sqrt(m)#
		#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
		X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
		z=X%*%a0#
		y=(z)^3 + rnorm(n,0,sigma)#
		# EDR estimate proposed by Hristache et al.#
		starter_edr = proc.time()#
		EDR <- edr(X,y,method = "HJPS")#
		edr_hat = -summary(EDR)$Rhat[1,]#
		time_edr = (proc.time() -starter_edr)[3]#
		# SSE#
		starter_sse = proc.time()#
		SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
		sse_hat = SSE$alpha#
		print(sse_hat)#
		time_sse = (proc.time() -starter_sse)[3]#
		# ESE#
		starter_ese = proc.time()#
		ESE <- ComputeESE(X,y,sse_hat,m)#
		ese_hat = ESE$alpha#
		time_ese = (proc.time() -starter_ese)[3]#
		## SSE_spline estimator#
		starter_sse_spline = proc.time()#
		sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
		sse_spline_hat = sse_spline$alpha#
		time_sse_spline = (proc.time() -starter_sse_spline)[3]#
	  ## ESE_spline computed via Lagrange + Broyden#
	  starter_ese_lagrange = proc.time()#
	  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
	  ese_lagrange_hat = ese_lagrange$theta#
	  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
	    ## spline estimator#
	    	starter_ese_spline = proc.time()#
	    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
	 	print(loc)#
	  	starter_ese_spline = proc.time()#
		ese_spline <- ComputeESE_spline(loc,X,y,sse_hat,m)#
	  	ese_spline_hat = ese_spline$alpha#
	  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
	  #Simest with sse_hat as starting point#
	  starter_simest= proc.time()#
	  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
	  time_simest = (proc.time() -starter_simest)[3]#
	  #Simest with sse_hat as starting point#
	  starter_simest0= proc.time()#
	  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
	  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
	  time_simest0 = (proc.time() -starter_simest0)[3]#
	  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
	timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
	  # Write edr-estimates (last column contains the computation time )#
	   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
	  #  # Write sse-estimates (last column contains the computation time )#
	  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
	  #    # Write ese-estimates (last column contains the computation time )#
	  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
	  #   # Write pls-estimates (last column contains the computation time )#
	  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
	  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
	   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
	  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
	   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
	   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
	   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
	}#
	  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
	pdf("BoxPlotThetaErrAndTime.pdf")#
	boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
	boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
	boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
	dev.off()#
	ese<-ComputeESE(X,y,sse_hat,m)#
		A <- ese$psi#
		B <- ese$derivative#
		C <- ese$data#
	    x1<-A[,1]#
	    y1<-A[,2]#
	    x2<-B[,1]#
	    y2<-B[,2]#
	    x<-C[,1]#
	   	y<-C[,2]#
	    f <- function(x) {x^3}#
	    x0<-seq(min(x1),max(x1),by=0.01)#
	    y0<-f(x0)#
	    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
	    lines(x1,y1,col="blue",lwd=2,type="s")#
	    lines(x0,y0,lwd=2,col="red",lty=2)#
	    points(x,y,pch = 21)#
	    g <- function(x) {3*x^2}#
	    x0<-seq(min(x2),max(x2),by=0.1)#
	    y0<-g(x0)#
	    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
	    lines(x2,y2,lwd=2)#
	    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,a0,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese<-ComputeESE(X,y,a0,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,a0,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,a0,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,edr_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,edr_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,a0,m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,a0,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,a0,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese<-ComputeESE(X,y,c(1,rep(0,m-1)),m)#
#
	A <- ese$psi_smooth#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
ese<-ComputeESE(X,y,c(1,rep(0,m-1)),m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,c(1,rep(0,m-1)),m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,c(1,rep(0,m-1)),m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
B<-read.table("psi_smooth.txt")#
   C<-read.table("data.txt")#
   f <- function(x) {x^3}#
   x<-B[,1]#
   y<-B[,2]#
   x0<-C[,1]#
   y0<-C[,2]#
   x1<-seq(min(x0),max(x0),by=0.01)#
   y1<-f(x1)	#
   plot(c(-1000,-1000),xlim=c(min(x),max(x)), ylim=c(min(y),max(y)), main= "",ylab="",xlab="",bty="n",las=1)#
   lines(x,y,lwd=3,col="blue")#
   points(x0,y0,pch = 21)#
   lines(x1,y1,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,c(1,rep(0,m-1)),m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,c(1,rep(0,m-1)),m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2,type="s")#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
ese_hat$derivative
ese$derivative
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 15#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,c(1,rep(0,m-1)),m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,c(1,rep(0,m-1)),m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 2000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = n^{1/5}, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
crossval <- function(X,y,dummy,m)#
{	#
  	min <- 1.0e8#
    for (i in 1:20)#
    {#
      	A<-ComputeESE_spline(0.02*i/20,X,y,dummy,m)#
      	a<-A$crossval#
      	if (!is.na(a))#
      	{#
      	    if (a<min)#
      	    {#
        	    min <-a#
        	    loc<-0.02*i/20#
      	    }#
      	}#
    }#
    return(loc)#
}#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 8)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	## SSE_spline estimator#
	starter_sse_spline = proc.time()#
	sse_spline = ComputeSSE_spline(0.1,X,y, sse_hat,m)#
	sse_spline_hat = sse_spline$alpha#
	time_sse_spline = (proc.time() -starter_sse_spline)[3]#
  ## ESE_spline computed via Lagrange + Broyden#
  starter_ese_lagrange = proc.time()#
  ese_lagrange = LagrangePLSE(X,y,sse_hat,deriv=TRUE)#
  ese_lagrange_hat = ese_lagrange$theta#
  time_ese_lagrange = (proc.time() -starter_ese_lagrange)[3]#
    ## spline estimator#
    	starter_ese_spline = proc.time()#
    loc<-crossval(X,y,c(1,rep(0,m-1)),m)#
 	print(loc)#
  	starter_ese_spline = proc.time()#
	ese_spline <- ComputeESE_spline(loc,X,y,c(1,rep(0,m-1)),m)#
  	ese_spline_hat = ese_spline$alpha#
  	time_ese_spline = (proc.time() -starter_ese_spline)[3]#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3]#
  #Simest with a0 as starting point#
  starter_simest0= proc.time()#
  simest_hat0 <- Alter_Min_Simest(X, y, beta_init = a0, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  # sim.est(X, y, beta.init = a0, lambda = n^{1/5}, method = "smooth.pen", progress = FALSE)#
  time_simest0 = (proc.time() -starter_simest0)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((sse_spline_hat- a0), "2"),norm((ese_lagrange_hat- a0), "2"),norm((ese_spline_hat- a0), "2"), norm((simest_hat-a0), "2"),norm((simest_hat0-a0), "2"))#
timeMat<- rbind(timeMat,c(time_edr,time_sse,time_ese,time_sse_spline,time_ese_lagrange,time_ese_spline,time_simest,time_simest0))#
  # Write edr-estimates (last column contains the computation time )#
   #write(c(edr_hat, time_edr),file = "EDR.txt", ncol =(m+1), append = TRUE)#
  #  # Write sse-estimates (last column contains the computation time )#
  #write(c(sse_hat, time_sse),file = "SSE.txt", ncol =(m+1),append = TRUE)#
  #    # Write ese-estimates (last column contains the computation time )#
  #write(c(ese_hat, time_ese),file = "ESE.txt", ncol =(m+1),append = TRUE)#
  #   # Write pls-estimates (last column contains the computation time )#
  #write(c(ese_spline_hat, time_ese_spline),file = "ESE_spline.txt", ncol =(m+1),append = TRUE)#
  #     # Write SSE_lagrange-estimates (last column contains the computation time )#
   #write(c(sse_lagrange_hat, time_sse_lagrange),file = "SSE_lagrange.txt", ncol =(m+1),append = TRUE)#
  #     # Write ESE_lagrange-estimates (last column contains the computation time )#
   #write(c(ese_lagrange_hat, time_ese_lagrange),file = "ESE_lagrange.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat$beta, time_simest),file = "Simest.txt", ncol =(m+1),append = TRUE)#
   #write(c(simest_hat0$beta, time_simest),file = "Simest0.txt", ncol =(m+1),append = TRUE)#
#
}#
#
  colnames(timeMat) <- c("EDR", "SSE", "ESE","SSE_sp", "ESE_Lg", "ESE_sp", "SimEst", "SimEst0")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |theta.hat-theta0|", las=2)#
boxplot(normMat, main= "Truncated Boxplot of |theta.hat-theta0|", ylim =c(0, 0.1), las=2)#
#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 4)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SimEst")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((simest_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_simest))#
}#
#
colnames(timeMat) <- c("EDR", "SSE","ESE", "SimEst")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 4)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SimEst")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((simest_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_simest))#
}#
#
colnames(timeMat) <- c("EDR", "SSE","ESE", "SimEst")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(pracma) #
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("LagrangePLSE.R")#
source("NewSimEst.R")#
#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("SSE_spline.cpp")#
sourceCpp("ESE_spline.cpp")#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 4)#
  colnames(normMat) <- c("EDR", "SSE", "ESE","SimEst")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((simest_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_simest))#
}#
#
colnames(timeMat) <- c("EDR", "SSE","ESE", "SimEst")#
pdf("BoxPlotThetaErrAndTime.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,1.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_ese = (proc.time() -starter_lse)[3]#
#
  #Simest with sse_hat as starting point#
  starter_simest= proc.time()#
  simest_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_simest = (proc.time() -starter_simest)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((simest_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_simest))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,1.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_ese = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,1.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_ese = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,1.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,0.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,0.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,0.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,0.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 5000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,0.5))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,max(esr_hat,ese_hat)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,max(edr_hat,ese_hat)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2*max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,3*max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,3*max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", ylim=c(0,2*max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, las=2, main="Run Times", las=2) #ylim=c(0,2*max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #ylim=c(0,2*max(time_edr,time_sse,time_ese,time_lse,time_PLSE)))#
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 2000#
  m= 10#
  sigma = 1#
  mu=0.05#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 10#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 10000#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 10#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 1000#
  n = 5000#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 5000#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 500#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
sourceCpp("spline.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 6)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","spline","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
	# spline#
	starter_spline = proc.time()#
	spline <- Compute_spline(X,y,sse_hat,m)#
	spline_hat = spline$alpha#
	time_spline = (proc.time() -starter_spline)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((spline_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_spline,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","spline","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-Compute_spline(X,y,sse_hat,m)#
#
	A <- ESE$psi#
	B <- ESE$derivative#
	C <- ESE$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(simest)#
args(sim.est)#
library(EDR)#
library(MASS)#
source("NewSimEst.R")#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
#
  NumIt = 100#
  n = 1000#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
#
  #PLSE with sse_hat as starting point#
  starter_PLSE= proc.time()#
  PLSE_hat <- Alter_Min_Simest(X, y, beta_init = sse_hat, lambda = 0.1, method = "smooth.pen", nmax= 100, maxit=100)#
  time_PLSE = (proc.time() -starter_PLSE)[3] #
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
ese<-ComputeESE(X,y,sse_hat,m)#
#
	A <- ese$psi#
	B <- ese$derivative#
	C <- ese$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x2<-B[,1]#
    y2<-B[,2]#
    x<-C[,1]#
   	y<-C[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)#
    g <- function(x) {3*x^2}#
    x0<-seq(min(x2),max(x2),by=0.1)#
    y0<-g(x0)#
    plot(c(-100,-100),xlim=c(min(x2),max(x2)), ylim=c(min(y2,y0),max(y2,y0)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x2,y2,lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(EDR)#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
sourceCpp("spline.cpp")#
#
  NumIt = 100#
  n = 50#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,lse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# PLSE#
	starter_PLSE = proc.time()#
	PLSE <- Compute_spline(X,y,c(1,rep(0,m-1)),m)#
	PLSE_hat = PLSE$alpha#
	time_PLSE = (proc.time() -starter_PLSE)[3]#
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
	A <- PLSE$psi#
	B <- PLSE$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x<-B[,1]#
   	y<-B[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(EDR)#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
sourceCpp("spline.cpp")#
#
  NumIt = 100#
  n = 100#
  m= 3#
  sigma = 1#
  #out=matrix(0,NumIt,m)#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	#X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,lse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# PLSE#
	starter_PLSE = proc.time()#
	PLSE <- Compute_spline(X,y,c(1,rep(0,m-1)),m)#
	PLSE_hat = PLSE$alpha#
	time_PLSE = (proc.time() -starter_PLSE)[3]#
#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
#
	A <- PLSE$psi#
	B <- PLSE$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x<-B[,1]#
   	y<-B[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
#########################################################
####   MONOTONE REGRESSION        #######
#########################################################
rm(list=ls())#
library(Rcpp)#
library(EDR)#
sourceCpp("SSE.cpp")#
sourceCpp("ESE.cpp")#
sourceCpp("LSE.cpp")#
sourceCpp("spline.cpp")#
#
  NumIt = 100#
  n = 50#
  m= 3#
  sigma = 1#
  timeMat <- NULL#
   normMat <- matrix(0, nrow= NumIt, ncol= 5)#
  colnames(normMat) <- c("EDR", "SSE","ESE","LSE","PLSE")#
for (j in 1: NumIt){#
  sim = 101+j#
  set.seed(sim)#
  print(j)#
#
  a0 = c(rep(1,m))/sqrt(m)#
	X = matrix(runif(m*n,1,2),n,m, byrow = FALSE)#
	#X = matrix(rnorm(m*n,0,sigma),n,m, byrow = FALSE)#
	z=X%*%a0#
	y=(z)^3 + rnorm(n,0,sigma)#
#
	# EDR estimate proposed by Hristache et al.#
	starter_edr = proc.time()#
	EDR <- edr(X,y,method = "HJPS")#
	edr_hat = -summary(EDR)$Rhat[1,]#
	time_edr = (proc.time() -starter_edr)[3]#
	# LSE#
	starter_lse = proc.time()#
	LSE <- ComputeLSE(X,y,c(1,rep(0,m-1)),m)#
	lse_hat = LSE$alpha#
	time_lse = (proc.time() -starter_lse)[3]#
	# SSE#
	starter_sse = proc.time()#
	SSE <- ComputeSSE(X,y,c(1,rep(0,m-1)),m)#
	sse_hat = SSE$alpha#
	time_sse = (proc.time() -starter_sse)[3]#
	# ESE#
	starter_ese = proc.time()#
	ESE <- ComputeESE(X,y,sse_hat,m)#
	ese_hat = ESE$alpha#
	time_ese = (proc.time() -starter_ese)[3]#
	# PLSE#
	starter_PLSE = proc.time()#
	PLSE <- Compute_spline(X,y,c(1,rep(0,m-1)),m)#
	PLSE_hat = PLSE$alpha#
	time_PLSE = (proc.time() -starter_PLSE)[3]#
  normMat[j,]  = c(norm((edr_hat- a0), "2"),norm((sse_hat- a0), "2"),norm((ese_hat- a0), "2"),norm((lse_hat-a0), "2"),norm((PLSE_hat-a0), "2"))#
timeMat<-rbind(timeMat,c(time_edr,time_sse,time_ese,time_lse,time_PLSE))#
}#
#
colnames(timeMat) <- c("EDR","SSE","ESE","LSE","PLSE")#
pdf("BoxPlot_alpha_err_and_time.pdf")#
boxplot(normMat, main= "Boxplot of |alpha_hat-alpha_0|", las=2)#
boxplot(timeMat, main="Run Times", las=2) #
dev.off()#
	A <- PLSE$psi#
	B <- PLSE$data#
#
    x1<-A[,1]#
    y1<-A[,2]#
    x<-B[,1]#
   	y<-B[,2]#
#
    f <- function(x) {x^3}#
    x0<-seq(min(x1),max(x1),by=0.01)#
    y0<-f(x0)#
    plot(c(-10000,-10000),xlim=c(min(x1),max(x1)), ylim=c(min(y,y0,y1),max(y,y0,y1)), main= "",ylab="",xlab="",bty="n",las=1)#
    lines(x1,y1,col="blue",lwd=2)#
    lines(x0,y0,lwd=2,col="red",lty=2)#
    points(x,y,pch = 21)
